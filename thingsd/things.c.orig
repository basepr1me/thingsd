/*
 * Copyright (c) 2016, 2019-2021 Tracey Emery <tracey@traceyemery.net>
 * Copyright (c) 2015 Mike Larkin <mlarkin@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/wait.h>
#include <sys/uio.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/mman.h>

#include <net/if.h>
#include <netinet/in.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <limits.h>
#include <poll.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <tls.h>
#include <unistd.h>
#include <util.h>

#include "proc.h"
#include "thingsd.h"

int	 things_dispatch_thingsd(int, struct privsep_proc *, struct imsg *);
void	 things_run(struct privsep *, struct privsep_proc *, void *);
void	 thing_serial_open(struct thing *, int);
int	 thing_setup(struct thing *, int);
int	 thing_sock_setup(struct socket *, int);
void	 thing_udp_event(int, short, void *);
void	 things_launch(void);

extern enum privsep_procid privsep_process;
/* struct thing compose_thing(struct thing *, enum imsg_type); */

static struct privsep_proc procs[] = {
	{ "thingsd",	PROC_PARENT,	things_dispatch_thingsd  },
};

void
things(struct privsep *ps, struct privsep_proc *p)
{
	proc_run(ps, p, procs, nitems(procs), things_run, NULL);
}

void
things_run(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	if (config_init(ps->ps_env) == -1)
		fatal("failed to initialize configuration");

	p->p_shutdown = things_shutdown;

	socket_rlimit(-1);

	signal_del(&ps->ps_evsigchld);
	signal_set(&ps->ps_evsigchld, SIGCHLD, things_sighdlr, ps);
	signal_add(&ps->ps_evsigchld, NULL);

	if (pledge("stdio inet recvfd", NULL) == -1)
		fatal("pledge");
}

void
things_launch(void)
{
	/* struct thing		*thing; */
	struct socket		*sock;
	/* evbuffercb		 thingrd = thing_rd; */
	/* evbuffercb		 thingwr = thing_wr; */

	/* TAILQ_FOREACH(thing, thingsd_env->things, entry) { */
	/* 	log_debug("%s: configuring thing %s (%d)", __func__, */
	/* 	    thing->conf.name, thing->fd); */

		/* TAILQ_FOREACH(sock, thing->sockets, entry) { */
		/* 	if (sock->conf.id == thing->conf.sock_id) { */
		/* 		log_debug("%s: assign thing %s listener %d", */
		/* 		    __func__, thing->conf.name, sock->conf.id); */
		/* 		thing->sock = sock; */
		/* 		break; */
		/* 	} */
		/* } */

		/* if ((thing->clients = calloc(1, */
		/*     sizeof(*thing->clients))) == NULL) */
		/* 	fatal("%s: calloc", __func__); */
		/* SPLAY_INIT(&thing->clients); */

		/* if (thing->conf.type == S_UDP) { */
		/* 	event_set(&thing->udp_ev, thing->fd, EV_READ | */
		/* 	    EV_PERSIST, thing_udp_event, thing); */
		/* 	if (event_add(&thing->udp_ev, NULL)) */
		/* 		fatalx("%s: udp ev error", __func__); */
		/* } else { */
			/* thing->bev = bufferevent_new(thing->fd, */
			/*     thingrd, thingwr, thing_err, thing); */

			/* if (thing->bev == NULL) */
			/* 	fatalx("%s: ipaddr bev error", __func__); */

			/* thing->evb = evbuffer_new(); */

			/* if (thing->evb == NULL) */
			/* 	fatalx("ipaddr evb error"); */

			/* bufferevent_enable(thing->bev, EV_READ | EV_WRITE); */
		/* } */
		/* log_debug("%s: running thing %s listening on %d", __func__, */
		/*     thing->conf.name, thing->conf.sock_id); */

	/* } */

	TAILQ_FOREACH(sock, thingsd_env->sockets, entry) {
		log_debug("%s: configuring thing listener %d (%d)", __func__,
		    sock->conf.id, sock->fd);

		socket_tls_init(sock);

		event_set(&sock->ev, sock->fd, EV_READ | EV_PERSIST,
		    client_conn, thingsd_env);

		if (event_add(&sock->ev, NULL))
			fatalx("event add sock");

		evtimer_set(&sock->pause, client_accept_paused, sock);

		log_debug("%s: running thing listener %d", __func__,
		    sock->conf.id);
	}
}

int
things_dispatch_thingsd(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct privsep		*ps = p->p_ps;
	int			 res = 0, cmd = 0, verbose;
	unsigned int		 mode;

	switch (imsg->hdr.type) {
	case IMSG_CFG_THINGS:
		config_getthing(thingsd_env, imsg, 0);
		break;
	case IMSG_CFG_SOCKS:
		config_getthing(thingsd_env, imsg, 1);
		break;
	case IMSG_CFG_DONE:
		config_getcfg(thingsd_env, imsg);
		break;
	case IMSG_CTL_RESET:
		IMSG_SIZE_CHECK(imsg, &mode);
		memcpy(&mode, imsg->data, sizeof(mode));

		config_getreset(thingsd_env, imsg);
		break;
	case IMSG_CTL_VERBOSE:
		IMSG_SIZE_CHECK(imsg, &verbose);
		memcpy(&verbose, imsg->data, sizeof(verbose));
		log_setverbose(verbose);
		break;
	case IMSG_CTL_START:
		things_launch();
		break;
	default:
		return (-1);
	}

	switch (cmd) {
	case 0:
		break;
	case IMSG_GET_INFO_THINGS_END_DATA:
		if (proc_compose_imsg(ps, PROC_PARENT, -1, cmd,
		    imsg->hdr.peerid, -1, &mode, sizeof(mode)) == -1)
			return (-1);
		break;
	default:
		if (proc_compose_imsg(ps, PROC_PARENT, -1, cmd,
		    imsg->hdr.peerid, -1, &res, sizeof(res)) == -1)
			return (-1);
		break;
	}

	return (0);
}

void
things_sighdlr(int sig, short event, void *arg)
{
	switch (sig) {
	default:
		fatalx("unexpected signal");
	}
}

void
thing_serial_open(struct thing *thing, int reconn)
{
	struct termios		 s_opts;
	int			 baudrate = 0, stop = 0;

	if (thing->conf.type == S_DEV) {

		/*
		 * Just a reminder to set the ownership of your serial
		 * devices to _thingsd. Otherwise, a thing will not be
		 * able to successfully open(2) the file descriptor.
		 */
		if ((thing->fd = open(thing->conf.location, O_RDWR |
		    O_NONBLOCK | O_NOCTTY | O_NDELAY)) == -1) {
			log_warnx("failed to open %s", thing->conf.location);

			if (reconn)
				return;

			/* dead_thing = new_dead_thing(thing); */

			/* env->exists = 1; */
			/* env->dcount++; */

			/* TAILQ_INSERT_TAIL(env->dead_things-> */
			/*     dead_things_list, dead_thing, entry); */

			return;
		} else {
			/* load current s_opts */
			tcgetattr(thing->fd, &s_opts);

			/* set baud */
			switch (thing->conf.baud) {
			case 50:
				baudrate = B50;
				break;
			case 75:
				baudrate = B75;
				break;
			case 110:
				baudrate = B110;
				break;
			case 134:
				baudrate = B134;
				break;
			case 150:
				baudrate = B150;
				break;
			case 200:
				baudrate = B200;
				break;
			case 300:
				baudrate = B300;
				break;
			case 600:
				baudrate = B600;
				break;
			case 1200:
				baudrate = B1200;
				break;
			case 1800:
				baudrate = B1800;
				break;
			case 2400:
				baudrate = B2400;
				break;
			case 4800:
				baudrate = B4800;
				break;
			case 9600:
				baudrate = B9600;
				break;
			case 19200:
				baudrate = B19200;
				break;
			case 38400:
				baudrate = B38400;
				break;
			case 57600:
				baudrate = B57600;
				break;
			case 76800:
				baudrate = B76800;
				break;
			case 115200:
				baudrate = B115200;
				break;
			}

			cfsetispeed(&s_opts, baudrate);
			cfsetospeed(&s_opts, baudrate);

			/* enable and set local */
			s_opts.c_cflag |= (CLOCAL | CREAD);

			/* set data bits */
			if (thing->conf.data_bits != -1) {
				s_opts.c_cflag &= ~CSIZE;
				switch(thing->conf.data_bits) {
				case 5:
					stop = CS5;
					break;
				case 6:
					stop = CS6;
					break;
				case 7:
					stop = CS7;
					break;
				case 8:
					stop = CS8;
					break;
				}
				s_opts.c_cflag |= stop;
			}

			/* set parity */
			if (strlen(thing->conf.parity) != 0) {
				s_opts.c_cflag &= ~PARENB;

				/* enable parity checking */
				if (strcmp(thing->conf.parity, "odd") == 0) {
					s_opts.c_cflag |= PARENB;
					s_opts.c_cflag |= PARODD;
					s_opts.c_iflag |= (INPCK |
					    ISTRIP);
				} else if (strcmp(thing->conf.parity,
				    "even") == 0) {
					s_opts.c_cflag |= PARENB;
					s_opts.c_cflag &= ~PARODD;
					s_opts.c_iflag |= (INPCK |
					    ISTRIP);
				}

			}

			/* set stop bits */
			if (thing->conf.stop_bits != -1) {
				if (thing->conf.stop_bits == 2)
					s_opts.c_cflag |= CSTOPB;
				else
					s_opts.c_cflag &= ~CSTOPB;
			}

			/* set hardware control */
			if (thing->conf.hw_ctl == 0) {
				s_opts.c_cflag &= ~CRTSCTS;
			} else {
				s_opts.c_cflag |= CRTSCTS;
			}

			/* set software control */
			if (thing->conf.sw_ctl == 0) {
				s_opts.c_iflag &= ~(IXON | IXOFF |
				    IXANY);
			} else {
				s_opts.c_iflag |= (IXON | IXOFF |
				    IXANY);
			}

			/* set input/output as raw */
			s_opts.c_lflag &= ~(ICANON | ECHO | ECHOE |
			    ISIG);

			s_opts.c_oflag &= ~OPOST;

			/* Set the new options for the port */
			tcsetattr(thing->fd, TCSANOW, &s_opts);

			if (thing->fd == '\0') {
				log_warnx("serial device not opened");
				/* if (reconn) */
				/* 	return; */
				/* add_reconn(thing); */
				return;
			}
		}

		/* if (reconn) { */
		/* 	thing->exists = 1; */
		/* 	log_info("reconnected: %s", thing->name); */
		/* } */
	}
}

int
thing_privinit(struct thing *thing)
{
	log_debug("%s: initializing thing %s", __func__, thing->conf.name);

	thing_serial_open(thing, 0);

	if (thing_setup(thing, 0) == -1)
		return (-1);

	return (0);
}

int
thing_sock_privinit(struct socket *sock)
{
	log_debug("%s: initializing thing listener %d", __func__,
	    sock->conf.id);

	if (thing_sock_setup(sock, 0) == -1)
		return (-1);

	return (0);
}

int
thing_sock_setup(struct socket *sock, int reconn)
{
	if ((sock->fd = create_socket(sock->conf.al, sock->conf.port,
	    S_TCP)) == -1) {
		log_warnx("%s: create sock socket failed", __func__);
		return (-1);
	}
	return (0);
}

int
thing_setup(struct thing *thing, int reconn)
{
	if (thing->conf.type == S_TCP) {
		if (thing->conf.persist == 1) {
			if ((thing->fd = open_client_socket(thing->conf.ipaddr,
			    &thing->conf.tcp_conn_port)) == -1) {
				log_warnx("%s: ipaddr connection failed",
				    __func__);
				if (reconn)
					goto done;
				/* add_reconn(thing); */
				goto done;
			}
		} else
			/* 0 indicates non-persistent socket */
			thing->fd = 0;
	}

	if (thing->conf.type == S_UDP) {
		if ((thing->fd = create_socket(thing->conf.udp_al,
		    thing->conf.udp_rcv_port, S_UDP)) == -1)
			fatalx("%s: create udp socket failed", __func__);
		goto done;
	}

	/* if (reconn) { */
	/* 	log_info("reconnected: %s", thing->name); */
	/* 	goto done; */
	/* } */
done:
	return (0);
}

void
things_reset(void)
{
	struct thing		*thing, *tthing;
	/* struct socket		*sock, *tsock; */
	/* struct client		*client, *tclient; */
	/* struct packet_client	*packet_client, *tpacket_client; */

	/* clean up packet clients */
	/* TAILQ_FOREACH_SAFE(packet_client, thingsd_env->packet_clients, entry, */
	/*     tpacket_client) { */
	/* 	TAILQ_REMOVE(thingsd_env->packet_clients, packet_client, entry); */
	/* } */

	/* clean up clients */
	/* TAILQ_FOREACH_SAFE(client, thingsd_env->clients, entry, tclient) { */
	/* 	close(client->fd); */
	/* 	TAILQ_REMOVE(thingsd_env->clients, client, entry); */
	/* } */

	/* clean up sockets */
	/* TAILQ_FOREACH_SAFE(sock, thingsd_env->sockets, entry, tsock) { */
	/* 	if (sock->tls) { */
	/* 		tls_config_free(sock->tls_config); */
	/* 		tls_free(sock->tls_ctx); */
	/* 	} */
	/* 	close(sock->fd); */
	/* 	TAILQ_REMOVE(thingsd_env->sockets, sock, entry); */
	/* } */

	/* clean up things */
	TAILQ_FOREACH_SAFE(thing, thingsd_env->things, entry, tthing) {
		close(thing->fd);
		TAILQ_REMOVE(thingsd_env->things, thing, entry);
	}

}

void
things_shutdown(void)
{
	/* struct thing		*thing, *tthing; */
	/* struct socket		*sock = NULL, *tsock; */
	/* struct client		*client, *tclient; */
	/* struct subscription	*sub, *tsub; */

	/* struct dead_thing	*dead_thing, *tdead_thing; */
	/* struct packet_client	*packet_client, *tpacket_client; */

	/* clean up packet clients */
	/* TAILQ_FOREACH_SAFE(packet_client, thingsd_env->packet_clients, entry, */
	/*     tpacket_client) { */
	/* 	TAILQ_REMOVE(thingsd_env->packet_clients, packet_client, entry); */
	/* 	free(packet_client); */
	/* } */

	/* clean up dead things */
	/* TAILQ_FOREACH_SAFE(dead_thing, */
	/*     thingsd_env->dead_things->dead_things_list, entry, tdead_thing) { */
	/* 	TAILQ_REMOVE(thingsd_env->dead_things->dead_things_list, */
	/* 	    dead_thing, entry); */
	/* 	free(dead_thing); */
	/* } */

	/* clean up clients */
	/* TAILQ_FOREACH_SAFE(client, thingsd_env->clients, entry, tclient) { */
	/* 	close(client->fd); */
	/* 	TAILQ_FOREACH_SAFE(sub, client->subscriptions, entry, tsub) */
	/* 		TAILQ_REMOVE(client->subscriptions, sub, entry); */
	/* 	free(client->subscriptions); */
	/* 	TAILQ_REMOVE(thingsd_env->clients, client, entry); */
	/* 	free(client); */
	/* } */
	/* free(thingsd_env->clients); */


	/* clean up sockets */

	/* TAILQ_FOREACH_SAFE(sock, thingsd_env->sockets, entry, tsock) { */
		/* TAILQ_FOREACH_SAFE(client, sock->clients, entry, tclient) { */
		/* 	if (client->bev != NULL) */
		/* 		bufferevent_disable(client->bev, */
		/* 		    EV_READ | EV_WRITE); */
		/* 	if (client->bev != NULL) */
		/* 		bufferevent_free(client->bev); */

		/* 	close(client->fd); */
		/* 	TAILQ_FOREACH_SAFE(sub, client->subscriptions, entry, */
		/* 	    tsub) */
		/* 		TAILQ_REMOVE(client->subscriptions, sub, entry); */
		/* 	free(client->subscriptions); */
		/* 	TAILQ_REMOVE(sock->clients, client, entry); */
		/* 	free(client); */
		/* } */
		/* free(thingsd_env->clients); */
		/* if (sock->conf.tls) { */
		/* 	tls_config_free(sock->tls_config); */
		/* 	tls_free(sock->tls_ctx); */
		/* 	/1* free(sock->conf.tls_cert); *1/ */
		/* 	/1* free(sock->conf.tls_cert_file); *1/ */
		/* 	/1* free(sock->conf.tls_key); *1/ */
		/* 	/1* free(sock->conf.tls_key_file); *1/ */
		/* 	free(sock->conf.tls_ca); */
		/* 	free(sock->conf.tls_ca_file); */
		/* 	free(sock->conf.tls_crl); */
		/* 	free(sock->conf.tls_crl_file); */
		/* 	free(sock->conf.tls_ocsp_staple); */
		/* 	free(sock->conf.tls_ocsp_staple_file); */
		/* } */
		/* event_del(&sock->ev); */
		/* evtimer_del(&sock->pause); */
		/* close(sock->fd); */
		/* TAILQ_REMOVE(thingsd_env->sockets, sock, entry); */
		/* free(sock); */
	/* } */
	/* free(thingsd_env->sockets); */

	/* clean up things */
	/* TAILQ_FOREACH_SAFE(thing, thingsd_env->things, entry, tthing) { */
	/* TAILQ_FOREACH_SAFE(sock, thing->sockets, entry, tsock) { */

		/* TAILQ_FOREACH_SAFE(client, sock->clients, entry, tclient) { */
		/* 	if (client->bev != NULL) */
		/* 		bufferevent_disable(client->bev, */
		/* 		    EV_READ | EV_WRITE); */
		/* 	if (client->bev != NULL) */
		/* 		bufferevent_free(client->bev); */

		/* 	close(client->fd); */
		/* 	TAILQ_FOREACH_SAFE(sub, client->subscriptions, entry, */
		/* 	    tsub) */
		/* 		TAILQ_REMOVE(client->subscriptions, sub, entry); */
		/* 	free(client->subscriptions); */
		/* 	TAILQ_REMOVE(sock->clients, client, entry); */
		/* 	free(client); */
		/* } */
		/* free(thingsd_env->clients); */
		/* if (sock->conf.tls) { */
		/* 	tls_config_free(sock->tls_config); */
		/* 	tls_free(sock->tls_ctx); */
		/* 	/1* free(sock->conf.tls_cert); *1/ */
		/* 	/1* free(sock->conf.tls_cert_file); *1/ */
		/* 	/1* free(sock->conf.tls_key); *1/ */
		/* 	/1* free(sock->conf.tls_key_file); *1/ */
		/* 	free(sock->conf.tls_ca); */
		/* 	free(sock->conf.tls_ca_file); */
		/* 	free(sock->conf.tls_crl); */
		/* 	free(sock->conf.tls_crl_file); */
		/* 	free(sock->conf.tls_ocsp_staple); */
		/* 	free(sock->conf.tls_ocsp_staple_file); */
		/* } */
		/* event_del(&sock->ev); */
		/* evtimer_del(&sock->pause); */
		/* close(sock->fd); */
		/* TAILQ_REMOVE(thing->sockets, sock, entry); */
		/* free(sock); */
	/* } */
	/* free(thing->sockets); */
		/* event_del(&thing->udp_ev); */
		/* if (thing->bev != NULL) */
		/* 	bufferevent_disable(thing->bev, EV_READ | EV_WRITE); */
		/* if (thing->bev != NULL) */
		/* 	bufferevent_free(thing->bev); */

		/* close(thing->fd); */
		/* TAILQ_REMOVE(thingsd_env->things, thing, entry); */
		/* free(thing); */
	/* } */
	free(thingsd_env->things);
	free(thingsd_env);
}

void
things_echo_pkt(struct privsep *ps, struct imsg *imsg)
{
	/* struct packet_client	*packet_client; */

	/* packet_client = calloc(1, sizeof(*packet_client)); */
	/* if (packet_client == NULL) */
	/* 	fatal("%s: calloc", __func__); */

	/* thingsd_env->packet_client_count++; */

	/* packet_client->ps = *ps; */
	/* packet_client->imsg = *imsg; */

	/* memcpy(packet_client->name, imsg->data,  sizeof(packet_client->name)); */

	/* log_debug("control packet echo request for %s", packet_client->name); */

	/* TAILQ_INSERT_TAIL(thingsd_env->packet_clients, packet_client, entry); */
}

/* void */
/* things_stop_pkt(struct privsep *ps, struct imsg *imsg) */
/* { */
/* 	struct packet_client	*packet_client, *tpacket_client; */
/* 	uint32_t		 fd; */

/* 	memcpy(&fd, imsg->data, sizeof(fd)); */

/* 	TAILQ_FOREACH_SAFE(packet_client, thingsd_env->packet_clients, entry, */
/* 	    tpacket_client) { */
/* 		if (fd == packet_client->imsg.hdr.peerid) { */
/* 			TAILQ_REMOVE(thingsd_env->packet_clients, */
/* 			    packet_client, entry); */
/* 			log_debug("control packet echo request stopping for %s", */
/* 			    packet_client->name); */
/* 			thingsd_env->packet_client_count--; */
/* 			free(packet_client); */
/* 			return; */
/* 		} */
/* 	} */

/* } */

void
things_show_info(struct privsep *ps, struct imsg *imsg)
{
	char filter[THINGSD_MAXNAME];
	struct thing *thing, nti;

	switch (imsg->hdr.type) {
	case IMSG_GET_INFO_THINGS_REQUEST:
	case IMSG_GET_INFO_THINGS_REQUEST_ROOT:

		memcpy(filter, imsg->data, sizeof(filter));

		TAILQ_FOREACH(thing, thingsd_env->things, entry) {
			if (filter[0] == '\0' || memcmp(filter,
			    thing->conf.name, sizeof(filter)) == 0) {
				/* nti = compose_thing(thing, imsg->hdr.type); */

				if (proc_compose_imsg(ps, PROC_CONTROL, -1,
				    IMSG_GET_INFO_THINGS_DATA,
				    imsg->hdr.peerid, -1, &nti,
				    sizeof(nti)) == -1)
					return;
			}
		}

		if (proc_compose_imsg(ps, PROC_CONTROL, -1,
		    IMSG_GET_INFO_THINGS_END_DATA, imsg->hdr.peerid,
			    -1, &nti, sizeof(nti)) == -1)
				return;

		break;
	default:
		log_debug("%s: error handling imsg", __func__);
		break;
	}
}

/* struct thing */
/* compose_thing(struct thing *thing, enum imsg_type type) */
/* { */
/* 	struct thing		 nti; */
/* 	char			 blank[9] = "********"; */

/* 	memset(&nti, 0, sizeof(nti)); */
/* 	nti.exists = thing->exists; */
/* 	nti.hw_ctl = thing->hw_ctl; */
/* 	nti.persist = thing->persist; */

/* 	memcpy(&nti.tcp_iface, thing->tcp_iface, sizeof(nti.tcp_iface)); */

/* 	memcpy(&nti.ipaddr, thing->ipaddr, sizeof(nti.ipaddr)); */

/* 	memcpy(&nti.parity, thing->parity, sizeof(nti.parity)); */

/* 	memcpy(&nti.name, thing->name, sizeof(nti.name)); */

/* 	nti.password[0] = '\0'; */
/* 	if (type == IMSG_GET_INFO_THINGS_REQUEST) */
/* 		memcpy(&nti.password, blank, sizeof(nti.password)); */
/* 	else */
/* 		memcpy(&nti.password, thing->password, */
/* 		    sizeof(nti.password)); */

/* 	memcpy(&nti.location, thing->location, sizeof(nti.location)); */

/* 	memcpy(&nti.udp, thing->udp, sizeof(nti.udp)); */

/* 	nti.fd = thing->fd; */
/* 	nti.baud = thing->baud; */
/* 	nti.conn_port = thing->conn_port; */
/* 	nti.rcv_port = thing->rcv_port; */
/* 	nti.data_bits = thing->data_bits; */
/* 	nti.max_clients = thing->max_clients; */
/* 	nti.port = thing->port; */
/* 	nti.stop_bits = thing->stop_bits; */
/* 	nti.type = thing->type; */
/* 	nti.client_cnt = thing->client_cnt; */

/* 	nti.tls = thing->tls; */
/* 	memcpy(&nti.tls_cert_file, thing->tls_cert_file, */
/* 	    sizeof(nti.tls_cert_file)); */

/* 	memcpy(&nti.tls_key_file, thing->tls_key_file, */
/* 	    sizeof(nti.tls_key_file)); */

/* 	memcpy(&nti.tls_ca_file, thing->tls_ca_file, */
/* 	    sizeof(nti.tls_ca_file)); */

/* 	memcpy(&nti.tls_crl_file, thing->tls_crl_file, */
/* 	    sizeof(nti.tls_crl_file)); */

/* 	memcpy(&nti.tls_ocsp_staple_file, thing->tls_ocsp_staple_file, */
/* 	    sizeof(nti.tls_ocsp_staple_file)); */

/* 	return nti; */
/* } */

/* void */
/* add_reconn(struct thing *thing) */
/* { */
/* 	struct dead_thing	*dead_thing; */

/* 	dead_thing = new_dead_thing(thing); */

/* 	thingsd_env->exists = 1; */
/* 	thingsd_env->dcount++; */

/* 	TAILQ_INSERT_TAIL(thingsd_env->dead_things->dead_things_list, */
/* 	    dead_thing, entry); */

/* } */

/* struct dead_thing */
/* *new_dead_thing(struct thing *thing) */
/* { */
/* 	struct dead_thing	*dead_thing; */

/* 	dead_thing = calloc(1, sizeof(*dead_thing)); */
/* 	if (dead_thing == NULL) */
/* 		fatal("%s: calloc", __func__); */

/* 	log_debug("%s: adding detached thing, %s", __func__, thing->name); */

/* 	memcpy(&dead_thing->name, thing->name, sizeof(dead_thing->name)); */

/* 	dead_thing->type = thing->type; */
/* 	dead_thing->dtime = time(NULL); */

/* 	return dead_thing; */
/* } */

/* void */
/* do_reconn(void) */
/* { */
/* 	struct dead_thing	*dead_thing, *tdead_thing; */
/* 	struct thing		*thing; */

/* 	TAILQ_FOREACH_SAFE(dead_thing, */
/* 	    thingsd_env->dead_things->dead_things_list, entry, tdead_thing) { */
/* 		if ((size_t)(time(NULL) - dead_thing->dtime) > */
/* 		    thingsd_env->conn_retry) { */
/* 			dead_thing->dtime = time(NULL); */

/* 			log_debug("attempting to reconnect %s", */
/* 			    dead_thing->name); */

/* 			switch (dead_thing->type) { */
/* 			case DEV: */
/* 				/1* open_things(thingsd_env, 1); *1/ */
/* 				break; */
/* 			case TCP: */
/* 				/1* create_sockets(thingsd_env, 1); *1/ */
/* 				break; */
/* 			} */
/* 		} */
/* 	} */

/* 	TAILQ_FOREACH_SAFE(dead_thing, */
/* 	    thingsd_env->dead_things->dead_things_list, entry, tdead_thing) { */
/* 		TAILQ_FOREACH(thing, thingsd_env->things, entry) { */
/* 			if (strcmp(thing->name, dead_thing->name) == 0 && */
/* 			    thing->exists) { */
/* 				TAILQ_REMOVE(thingsd_env->dead_things-> */
/* 				    dead_things_list, */
/* 				    dead_thing, entry); */
/* 				thingsd_env->dcount--; */

/* 				free(dead_thing); */

/* 				return; */
/* 			} */
/* 		} */
/* 	} */

/* 	if (thingsd_env->dcount == 0) */
/* 		thingsd_env->exists = 0; */
/* } */

/* void */
/* send_to_packet_client(struct thingsd *env, char *name, char *pkt, int len) */
/* { */
/* 	struct packet_client	*packet_client; */
/* 	int			 snm; */

/* 	TAILQ_FOREACH(packet_client, env->packet_clients, entry) { */
/* 		if (strlen(packet_client->name) != 0) { */
/* 			snm = strcmp(name, packet_client->name); */
/* 			if (snm == 0) */
/* 				if (proc_compose_imsg(&packet_client->ps, */
/* 				    PROC_CONTROL, -1, IMSG_SHOW_PACKETS_DATA, */
/* 				    packet_client->imsg.hdr.peerid, -1, */
/* 				    pkt, len) == -1) */
/* 				return; */
/* 		} */
/* 	} */
/* } */

void
thing_rd(struct bufferevent *bev, void *arg)
{
	/* struct thingsd		*env = (struct thingsd *)arg; */
	/* struct thing		*thing = (struct thing *) arg; */
	/* struct socket		*sock, *csock = NULL; */
	/* struct client		*client; */
	/* struct subscription	*sub; */
	/* size_t			 len; */
	/* int			 fd = bev->ev_read.ev_fd; */
	/* char			*pkt = NULL; */

	/* log_info("%s", __func__); */
	/* TAILQ_FOREACH(thing, thingsd_env->things, entry) */
	/* 	if (thing->fd == fd) */
	/* 		break; */

	/* sock = thing->sock; */
	/* TAILQ_FOREACH(csock, thing->sockets, entry) */
	/* 	if (sock->conf.child_id == csock->conf.id) */
	/* 		break; */

	/* thing->evb = EVBUFFER_INPUT(bev); */

	/* len = EVBUFFER_LENGTH(thing->evb); */

	/* if ((pkt = calloc(len, sizeof(*pkt))) == NULL) */
	/* 	return; */

	/* evbuffer_remove(thing->evb, pkt, len); */
/* log_info("Pkt: %s", pkt); */
	/* TAILQ_FOREACH(client, thing->clients, entry) */
	/* 	TAILQ_FOREACH(sub, client->subscriptions, entry) */
	/* 		if (strcmp(sub->thing_name, thing->conf.name) == 0) */
	/* 			bufferevent_write(client->bev, pkt, len); */

	/* if (env->packet_client_count > 0) */
	/* 	send_to_packet_client(env, thing->name, pkt, */
	/* 	    len); */

	/* if (csock != NULL) */
	/* 	TAILQ_FOREACH(client, csock->clients, entry) */
	/* 		TAILQ_FOREACH(sub, client->subscriptions, entry) */
	/* 			if (strcmp(sub->thing_name, */
	/* 			    thing->conf.name) == 0) */
	/* 				bufferevent_write(client->bev, pkt, */
	/* 				    len); */
	/* free(pkt); */
}

void
thing_wr(struct bufferevent *bev, void *arg)
{
}

void
thing_err(struct bufferevent *bev, short error, void *arg)
{
	struct thingsd		*env = (struct thingsd *)arg;
	struct thing		*thing = NULL;
	int			 fd = bev->ev_read.ev_fd;

	if ((error & EVBUFFER_ERROR) == 0 || error & EVBUFFER_TIMEOUT) {
		TAILQ_FOREACH(thing, env->things, entry) {
			if (thing->fd == fd && thing->conf.persist) {
				if (thing->bev != NULL)
					bufferevent_disable(thing->bev,
					    EV_READ | EV_WRITE);
				if (thing->bev != NULL)
					bufferevent_free(thing->bev);
				thing->evb = NULL;
				thing->bev = NULL;
				close(thing->fd);
				thing->fd = -1;
				/* add_reconn(thing); */
				log_warnx("thing error: %s disconnected",
				    thing->conf.name);
			}
		}
	}
}

void
thing_udp_event(int fd, short event, void *arg)
{
	/* struct thingsd		*env = (struct thingsd *)arg; */
	/* struct thing		*thing = (struct thing *) arg; */
	/* struct client		*client = NULL; */
	/* struct package		*package = NULL, *pkg; */
	/* struct subscription	*sub = NULL; */
	/* struct sockaddr		*addr = NULL; */
	/* struct socket		*sock, *csock = NULL; */
	/* char			 pkt[PKT_BUFF]; */
	/* socklen_t		*addrlen = NULL; */

	/* memset(pkt, 0, sizeof(pkt)); */

	/* TAILQ_FOREACH(thing, env->things, entry) */
	/* 	if (thing->fd == fd) */
	/* 		break; */

	/* sock = thing->sock; */
	/* TAILQ_FOREACH(csock, env->sockets, entry) */
	/* 	if (sock->conf.child_id == csock->conf.id) */
	/* 		break; */

	/*
	 * XXX: I think events race here. Figure that out. But, I think that
	 * the len variable is getting changed before the write event can
	 * even happen.
	 *
	 * Update, it looks like each privsep process isn'ta  full copy? You
	 * still don't understand what the fuck you're doing.
	 *
	 * write to clients
	 */


	/* if ((package = calloc(1, sizeof(*package))) == NULL) */
	/* 	fatalx("%s: calloc", __func__); */
	/* if ((package->pkt = calloc(1, sizeof(*package->pkt))) == NULL) */
	/* 	fatalx("%s: calloc", __func__); */

	/* package->len = recvfrom(fd, pkt, sizeof(pkt), 0, addr, addrlen); */

	/* if (package->len == -1) */
	/* 	goto done; */

	/* if (snprintf(package->pkt, package->len, "%s", pkt) < 0) */
	/* 	fatal("%s: snprintf", __func__); */
/* log_info("Pkt: %s", package->pkt); */
	/* while ((client = SPLAY_ROOT(&thing->clients)) != NULL) */

	/* SPLAY_FOREACH(client, clientlist, &thing->clients) */
	/* 	bufferevent_write(client->bev, package->pkt, package->len); */
	/* TAILQ_FOREACH(client, thing->clients, entry) { */
	/* log_info("create package %s", package->pkt); */
	/* 	TAILQ_FOREACH(sub, client->subscriptions, entry) { */
	/* 		if (strcmp(sub->thing_name, */
	/* 		    thing->conf.name) == 0) { */
	/* 			/1* package->bev = client->bev; *1/ */
	/* 			log_info("enter package"); */
	/* 			/1* TAILQ_INSERT_TAIL(client->packages, package, *1/ */
	/* 			/1*     entry); *1/ */
	/* 			bufferevent_write(client->bev, package->pkt, */
	/* 			    package->len); */
	/* 		} */
	/* 	} */
	/* } */
	/* if (csock != NULL) */
	/* 	TAILQ_FOREACH(client, csock->clients, entry) */
	/* 		TAILQ_FOREACH(sub, client->subscriptions, entry) */
	/* 			if (strcmp(sub->thing_name, */
	/* 			    thing->conf.name) == 0) { */
	/* 				/1* package->bev = client->bev; *1/ */
	/* 			log_info("enter cpackage"); */
	/* 				/1* TAILQ_INSERT_TAIL(client->packages, *1/ */
	/* 				/1*     package, entry); *1/ */
	/* 			} */


	/* TAILQ_FOREACH(pkg, client->packages, entry) { */
	/* 	log_info("write pkg"); */
	/* 	bufferevent_write(pkg->bev, pkg->pkt, pkg->len); */
	/* } */
/* done: */
/* 	free(package->pkt); */
/* 	free(package); */
	/* if (env->packet_client_count > 0) */
	/* 	send_to_packet_client(env, thing->name, pkt, len); */
}

int
thing_client_cmp(struct client *a, struct client *b)
{
	return ((int)a->id - b->id);
}
